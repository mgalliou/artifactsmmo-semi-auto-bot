/*
 * Artifacts API
 *
 *  Artifacts is an API-based MMO game where you can manage 5 characters to explore, fight, gather resources, craft items and much more.  Website: https://artifactsmmo.com/  Documentation: https://docs.artifactsmmo.com/  OpenAPI Spec: https://api.artifactsmmo.com/openapi.json 
 *
 * The version of the OpenAPI document: 6.1.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`action_accept_new_task_my_name_action_task_new_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionAcceptNewTaskMyNameActionTaskNewPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status489(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_buy_bank_expansion_my_name_action_bank_buy_expansion_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionBuyBankExpansionMyNameActionBankBuyExpansionPostError {
    Status598(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status492(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_change_skin_my_name_action_change_skin_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionChangeSkinMyNameActionChangeSkinPostError {
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status550(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_complete_task_my_name_action_task_complete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionCompleteTaskMyNameActionTaskCompletePostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status488(models::ErrorResponseSchema),
    Status487(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_crafting_my_name_action_crafting_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionCraftingMyNameActionCraftingPostError {
    Status404(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status493(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_delete_item_my_name_action_delete_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDeleteItemMyNameActionDeletePostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_deposit_bank_gold_my_name_action_bank_deposit_gold_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDepositBankGoldMyNameActionBankDepositGoldPostError {
    Status598(models::ErrorResponseSchema),
    Status492(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status461(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_deposit_bank_item_my_name_action_bank_deposit_item_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionDepositBankItemMyNameActionBankDepositItemPostError {
    Status598(models::ErrorResponseSchema),
    Status404(models::ErrorResponseSchema),
    Status461(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status462(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_equip_item_my_name_action_equip_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionEquipItemMyNameActionEquipPostError {
    Status404(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status483(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status496(models::ErrorResponseSchema),
    Status491(models::ErrorResponseSchema),
    Status485(models::ErrorResponseSchema),
    Status484(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_fight_my_name_action_fight_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionFightMyNameActionFightPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_gathering_my_name_action_gathering_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGatheringMyNameActionGatheringPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status493(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_ge_buy_item_my_name_action_grandexchange_buy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGeBuyItemMyNameActionGrandexchangeBuyPostError {
    Status598(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status436(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status492(models::ErrorResponseSchema),
    Status434(models::ErrorResponseSchema),
    Status435(models::ErrorResponseSchema),
    Status404(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_ge_cancel_sell_order_my_name_action_grandexchange_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostError {
    Status598(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status436(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status438(models::ErrorResponseSchema),
    Status404(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_ge_create_sell_order_my_name_action_grandexchange_sell_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status404(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status492(models::ErrorResponseSchema),
    Status433(models::ErrorResponseSchema),
    Status437(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_give_gold_my_name_action_give_gold_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGiveGoldMyNameActionGiveGoldPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status492(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_give_items_my_name_action_give_item_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionGiveItemsMyNameActionGiveItemPostError {
    Status404(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_move_my_name_action_move_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionMoveMyNameActionMovePostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status490(models::ErrorResponseSchema),
    Status404(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status595(models::ErrorResponseSchema),
    Status596(models::ErrorResponseSchema),
    Status496(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_npc_buy_item_my_name_action_npc_buy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionNpcBuyItemMyNameActionNpcBuyPostError {
    Status598(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status492(models::ErrorResponseSchema),
    Status441(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status404(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_npc_sell_item_my_name_action_npc_sell_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionNpcSellItemMyNameActionNpcSellPostError {
    Status598(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status442(models::ErrorResponseSchema),
    Status404(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_recycling_my_name_action_recycling_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionRecyclingMyNameActionRecyclingPostError {
    Status404(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status493(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status473(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_rest_my_name_action_rest_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionRestMyNameActionRestPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_task_cancel_my_name_action_task_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionTaskCancelMyNameActionTaskCancelPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_task_exchange_my_name_action_task_exchange_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionTaskExchangeMyNameActionTaskExchangePostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_task_trade_my_name_action_task_trade_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionTaskTradeMyNameActionTaskTradePostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status475(models::ErrorResponseSchema),
    Status474(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_transition_my_name_action_transition_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionTransitionMyNameActionTransitionPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status404(models::ErrorResponseSchema),
    Status492(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status496(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_unequip_item_my_name_action_unequip_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionUnequipItemMyNameActionUnequipPostError {
    Status404(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status491(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status483(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_use_item_my_name_action_use_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionUseItemMyNameActionUsePostError {
    Status404(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status476(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status496(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_withdraw_bank_gold_my_name_action_bank_withdraw_gold_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError {
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status461(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status460(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`action_withdraw_bank_item_my_name_action_bank_withdraw_item_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ActionWithdrawBankItemMyNameActionBankWithdrawItemPostError {
    Status404(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    Status499(models::ErrorResponseSchema),
    Status461(models::ErrorResponseSchema),
    Status486(models::ErrorResponseSchema),
    Status497(models::ErrorResponseSchema),
    Status598(models::ErrorResponseSchema),
    Status478(models::ErrorResponseSchema),
    Status422(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_characters_logs_my_logs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllCharactersLogsMyLogsGetError {
    Status404(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_character_logs_my_logs_name_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCharacterLogsMyLogsNameGetError {
    Status404(models::ErrorResponseSchema),
    Status498(models::ErrorResponseSchema),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_characters_my_characters_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyCharactersMyCharactersGetError {
    UnknownValue(serde_json::Value),
}


/// Accepting a new task.
pub fn action_accept_new_task_my_name_action_task_new_post(configuration: &configuration::Configuration, name: &str) -> Result<models::TaskResponseSchema, Error<ActionAcceptNewTaskMyNameActionTaskNewPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!("{}/my/{name}/action/task/new", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionAcceptNewTaskMyNameActionTaskNewPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Buy a 20 slots bank expansion.
pub fn action_buy_bank_expansion_my_name_action_bank_buy_expansion_post(configuration: &configuration::Configuration, name: &str) -> Result<models::BankExtensionTransactionResponseSchema, Error<ActionBuyBankExpansionMyNameActionBankBuyExpansionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!("{}/my/{name}/action/bank/buy_expansion", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankExtensionTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankExtensionTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionBuyBankExpansionMyNameActionBankBuyExpansionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Change the skin of your character.
pub fn action_change_skin_my_name_action_change_skin_post(configuration: &configuration::Configuration, name: &str, change_skin_character_schema: models::ChangeSkinCharacterSchema) -> Result<models::ChangeSkinResponseSchema, Error<ActionChangeSkinMyNameActionChangeSkinPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_change_skin_character_schema = change_skin_character_schema;

    let uri_str = format!("{}/my/{name}/action/change_skin", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_change_skin_character_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChangeSkinResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChangeSkinResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionChangeSkinMyNameActionChangeSkinPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Complete a task.
pub fn action_complete_task_my_name_action_task_complete_post(configuration: &configuration::Configuration, name: &str) -> Result<models::RewardDataResponseSchema, Error<ActionCompleteTaskMyNameActionTaskCompletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!("{}/my/{name}/action/task/complete", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RewardDataResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RewardDataResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionCompleteTaskMyNameActionTaskCompletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Craft an item. The character must be on a map with a workshop.
pub fn action_crafting_my_name_action_crafting_post(configuration: &configuration::Configuration, name: &str, crafting_schema: models::CraftingSchema) -> Result<models::SkillResponseSchema, Error<ActionCraftingMyNameActionCraftingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_crafting_schema = crafting_schema;

    let uri_str = format!("{}/my/{name}/action/crafting", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_crafting_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SkillResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SkillResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionCraftingMyNameActionCraftingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete an item from your character's inventory.
pub fn action_delete_item_my_name_action_delete_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: models::SimpleItemSchema) -> Result<models::DeleteItemResponseSchema, Error<ActionDeleteItemMyNameActionDeletePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/delete", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DeleteItemResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DeleteItemResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionDeleteItemMyNameActionDeletePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deposit gold in a bank on the character's map.
pub fn action_deposit_bank_gold_my_name_action_bank_deposit_gold_post(configuration: &configuration::Configuration, name: &str, deposit_withdraw_gold_schema: models::DepositWithdrawGoldSchema) -> Result<models::BankGoldTransactionResponseSchema, Error<ActionDepositBankGoldMyNameActionBankDepositGoldPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_deposit_withdraw_gold_schema = deposit_withdraw_gold_schema;

    let uri_str = format!("{}/my/{name}/action/bank/deposit/gold", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_deposit_withdraw_gold_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankGoldTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankGoldTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionDepositBankGoldMyNameActionBankDepositGoldPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Deposit multiple items in a bank on the character's map. The cooldown will be 3 seconds multiplied by the number of different items deposited.
pub fn action_deposit_bank_item_my_name_action_bank_deposit_item_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: Vec<models::SimpleItemSchema>) -> Result<models::BankItemTransactionResponseSchema, Error<ActionDepositBankItemMyNameActionBankDepositItemPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/bank/deposit/item", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankItemTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankItemTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionDepositBankItemMyNameActionBankDepositItemPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Equip an item on your character.
pub fn action_equip_item_my_name_action_equip_post(configuration: &configuration::Configuration, name: &str, equip_schema: models::EquipSchema) -> Result<models::EquipmentResponseSchema, Error<ActionEquipItemMyNameActionEquipPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_equip_schema = equip_schema;

    let uri_str = format!("{}/my/{name}/action/equip", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_equip_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EquipmentResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EquipmentResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionEquipItemMyNameActionEquipPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Start a fight against a monster on the character's map. Add participants for multi-character fights (up to 3 characters, only for boss).
pub fn action_fight_my_name_action_fight_post(configuration: &configuration::Configuration, name: &str, fight_request_schema: Option<models::FightRequestSchema>) -> Result<models::CharacterFightResponseSchema, Error<ActionFightMyNameActionFightPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_fight_request_schema = fight_request_schema;

    let uri_str = format!("{}/my/{name}/action/fight", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_fight_request_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CharacterFightResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CharacterFightResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionFightMyNameActionFightPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Harvest a resource on the character's map.
pub fn action_gathering_my_name_action_gathering_post(configuration: &configuration::Configuration, name: &str) -> Result<models::SkillResponseSchema, Error<ActionGatheringMyNameActionGatheringPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!("{}/my/{name}/action/gathering", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SkillResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SkillResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGatheringMyNameActionGatheringPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Buy an item at the Grand Exchange on the character's map.
pub fn action_ge_buy_item_my_name_action_grandexchange_buy_post(configuration: &configuration::Configuration, name: &str, ge_buy_order_schema: models::GeBuyOrderSchema) -> Result<models::GeTransactionResponseSchema, Error<ActionGeBuyItemMyNameActionGrandexchangeBuyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_ge_buy_order_schema = ge_buy_order_schema;

    let uri_str = format!("{}/my/{name}/action/grandexchange/buy", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_ge_buy_order_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GeTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GeTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGeBuyItemMyNameActionGrandexchangeBuyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel a sell order at the Grand Exchange on the character's map.
pub fn action_ge_cancel_sell_order_my_name_action_grandexchange_cancel_post(configuration: &configuration::Configuration, name: &str, ge_cancel_order_schema: models::GeCancelOrderSchema) -> Result<models::GeTransactionResponseSchema, Error<ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_ge_cancel_order_schema = ge_cancel_order_schema;

    let uri_str = format!("{}/my/{name}/action/grandexchange/cancel", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_ge_cancel_order_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GeTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GeTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGeCancelSellOrderMyNameActionGrandexchangeCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Create a sell order at the Grand Exchange on the character's map.  Please note there is a 3% listing tax, charged at the time of posting, on the total price.
pub fn action_ge_create_sell_order_my_name_action_grandexchange_sell_post(configuration: &configuration::Configuration, name: &str, ge_order_creationr_schema: models::GeOrderCreationrSchema) -> Result<models::GeCreateOrderTransactionResponseSchema, Error<ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_ge_order_creationr_schema = ge_order_creationr_schema;

    let uri_str = format!("{}/my/{name}/action/grandexchange/sell", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_ge_order_creationr_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GeCreateOrderTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GeCreateOrderTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGeCreateSellOrderMyNameActionGrandexchangeSellPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Give gold to another character in your account on the same map.
pub fn action_give_gold_my_name_action_give_gold_post(configuration: &configuration::Configuration, name: &str, give_gold_schema: models::GiveGoldSchema) -> Result<models::GiveGoldResponseSchema, Error<ActionGiveGoldMyNameActionGiveGoldPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_give_gold_schema = give_gold_schema;

    let uri_str = format!("{}/my/{name}/action/give/gold", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_give_gold_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GiveGoldResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GiveGoldResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGiveGoldMyNameActionGiveGoldPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Give items to another character in your account on the same map. The cooldown will be 3 seconds multiplied by the number of different items given.
pub fn action_give_items_my_name_action_give_item_post(configuration: &configuration::Configuration, name: &str, give_items_schema: models::GiveItemsSchema) -> Result<models::GiveItemResponseSchema, Error<ActionGiveItemsMyNameActionGiveItemPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_give_items_schema = give_items_schema;

    let uri_str = format!("{}/my/{name}/action/give/item", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_give_items_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GiveItemResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GiveItemResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionGiveItemsMyNameActionGiveItemPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Moves a character on the map using either the map's ID or X and Y position. Provide either 'map_id' or both 'x' and 'y' coordinates in the request body.
pub fn action_move_my_name_action_move_post(configuration: &configuration::Configuration, name: &str, destination_schema: models::DestinationSchema) -> Result<models::CharacterMovementResponseSchema, Error<ActionMoveMyNameActionMovePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_destination_schema = destination_schema;

    let uri_str = format!("{}/my/{name}/action/move", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_destination_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CharacterMovementResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CharacterMovementResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionMoveMyNameActionMovePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Buy an item from an NPC on the character's map.
pub fn action_npc_buy_item_my_name_action_npc_buy_post(configuration: &configuration::Configuration, name: &str, npc_merchant_buy_schema: models::NpcMerchantBuySchema) -> Result<models::NpcMerchantTransactionResponseSchema, Error<ActionNpcBuyItemMyNameActionNpcBuyPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_npc_merchant_buy_schema = npc_merchant_buy_schema;

    let uri_str = format!("{}/my/{name}/action/npc/buy", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_npc_merchant_buy_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NpcMerchantTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NpcMerchantTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionNpcBuyItemMyNameActionNpcBuyPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sell an item to an NPC on the character's map.
pub fn action_npc_sell_item_my_name_action_npc_sell_post(configuration: &configuration::Configuration, name: &str, npc_merchant_buy_schema: models::NpcMerchantBuySchema) -> Result<models::NpcMerchantTransactionResponseSchema, Error<ActionNpcSellItemMyNameActionNpcSellPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_npc_merchant_buy_schema = npc_merchant_buy_schema;

    let uri_str = format!("{}/my/{name}/action/npc/sell", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_npc_merchant_buy_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NpcMerchantTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NpcMerchantTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionNpcSellItemMyNameActionNpcSellPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Recycling an item. The character must be on a map with a workshop (only for equipments and weapons).
pub fn action_recycling_my_name_action_recycling_post(configuration: &configuration::Configuration, name: &str, recycling_schema: models::RecyclingSchema) -> Result<models::RecyclingResponseSchema, Error<ActionRecyclingMyNameActionRecyclingPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_recycling_schema = recycling_schema;

    let uri_str = format!("{}/my/{name}/action/recycling", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_recycling_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RecyclingResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RecyclingResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionRecyclingMyNameActionRecyclingPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Recovers hit points by resting. (1 second per 5 HP, minimum 3 seconds)
pub fn action_rest_my_name_action_rest_post(configuration: &configuration::Configuration, name: &str) -> Result<models::CharacterRestResponseSchema, Error<ActionRestMyNameActionRestPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!("{}/my/{name}/action/rest", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CharacterRestResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CharacterRestResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionRestMyNameActionRestPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Cancel a task for 1 tasks coin.
pub fn action_task_cancel_my_name_action_task_cancel_post(configuration: &configuration::Configuration, name: &str) -> Result<models::TaskCancelledResponseSchema, Error<ActionTaskCancelMyNameActionTaskCancelPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!("{}/my/{name}/action/task/cancel", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskCancelledResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskCancelledResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionTaskCancelMyNameActionTaskCancelPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Exchange 6 tasks coins for a random reward. Rewards are exclusive items or resources.
pub fn action_task_exchange_my_name_action_task_exchange_post(configuration: &configuration::Configuration, name: &str) -> Result<models::RewardDataResponseSchema, Error<ActionTaskExchangeMyNameActionTaskExchangePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!("{}/my/{name}/action/task/exchange", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RewardDataResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RewardDataResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionTaskExchangeMyNameActionTaskExchangePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Trading items with a Tasks Master.
pub fn action_task_trade_my_name_action_task_trade_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: models::SimpleItemSchema) -> Result<models::TaskTradeResponseSchema, Error<ActionTaskTradeMyNameActionTaskTradePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/task/trade", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TaskTradeResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TaskTradeResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionTaskTradeMyNameActionTaskTradePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Execute a transition from the current map to another layer. The character must be on a map that has a transition available.
pub fn action_transition_my_name_action_transition_post(configuration: &configuration::Configuration, name: &str) -> Result<models::CharacterTransitionResponseSchema, Error<ActionTransitionMyNameActionTransitionPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;

    let uri_str = format!("{}/my/{name}/action/transition", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CharacterTransitionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CharacterTransitionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionTransitionMyNameActionTransitionPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Unequip an item on your character.
pub fn action_unequip_item_my_name_action_unequip_post(configuration: &configuration::Configuration, name: &str, unequip_schema: models::UnequipSchema) -> Result<models::EquipmentResponseSchema, Error<ActionUnequipItemMyNameActionUnequipPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_unequip_schema = unequip_schema;

    let uri_str = format!("{}/my/{name}/action/unequip", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_unequip_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EquipmentResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EquipmentResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionUnequipItemMyNameActionUnequipPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Use an item as a consumable.
pub fn action_use_item_my_name_action_use_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: models::SimpleItemSchema) -> Result<models::UseItemResponseSchema, Error<ActionUseItemMyNameActionUsePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/use", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UseItemResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UseItemResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionUseItemMyNameActionUsePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Withdraw gold from your bank.
pub fn action_withdraw_bank_gold_my_name_action_bank_withdraw_gold_post(configuration: &configuration::Configuration, name: &str, deposit_withdraw_gold_schema: models::DepositWithdrawGoldSchema) -> Result<models::BankGoldTransactionResponseSchema, Error<ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_deposit_withdraw_gold_schema = deposit_withdraw_gold_schema;

    let uri_str = format!("{}/my/{name}/action/bank/withdraw/gold", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_deposit_withdraw_gold_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankGoldTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankGoldTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionWithdrawBankGoldMyNameActionBankWithdrawGoldPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Take items from your bank and put them in the character's inventory. The cooldown will be 3 seconds multiplied by the number of different items withdrawn.
pub fn action_withdraw_bank_item_my_name_action_bank_withdraw_item_post(configuration: &configuration::Configuration, name: &str, simple_item_schema: Vec<models::SimpleItemSchema>) -> Result<models::BankItemTransactionResponseSchema, Error<ActionWithdrawBankItemMyNameActionBankWithdrawItemPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_body_simple_item_schema = simple_item_schema;

    let uri_str = format!("{}/my/{name}/action/bank/withdraw/item", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_simple_item_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BankItemTransactionResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BankItemTransactionResponseSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<ActionWithdrawBankItemMyNameActionBankWithdrawItemPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// History of the last 5000 actions of all your characters.
pub fn get_all_characters_logs_my_logs_get(configuration: &configuration::Configuration, page: Option<u32>, size: Option<u32>) -> Result<models::DataPageLogSchema, Error<GetAllCharactersLogsMyLogsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_page = page;
    let p_query_size = size;

    let uri_str = format!("{}/my/logs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DataPageLogSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DataPageLogSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<GetAllCharactersLogsMyLogsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// History of the last actions of your character.
pub fn get_character_logs_my_logs_name_get(configuration: &configuration::Configuration, name: &str, page: Option<u32>, size: Option<u32>) -> Result<models::DataPageLogSchema, Error<GetCharacterLogsMyLogsNameGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_name = name;
    let p_query_page = page;
    let p_query_size = size;

    let uri_str = format!("{}/my/logs/{name}", configuration.base_path, name=crate::apis::urlencode(p_path_name));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_size {
        req_builder = req_builder.query(&[("size", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DataPageLogSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DataPageLogSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<GetCharacterLogsMyLogsNameGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// List of your characters.
pub fn get_my_characters_my_characters_get(configuration: &configuration::Configuration, ) -> Result<models::MyCharactersListSchema, Error<GetMyCharactersMyCharactersGetError>> {

    let uri_str = format!("{}/my/characters", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req)?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text()?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MyCharactersListSchema`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MyCharactersListSchema`")))),
        }
    } else {
        let content = resp.text()?;
        let entity: Option<GetMyCharactersMyCharactersGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

